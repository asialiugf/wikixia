# packages/test01子项目引用 @asialine/xia-ui/XIcon组件
在root下，执行了 pnpm up
```ts
import type { ExtractPropTypes } from "vue";
```
以上必须是 import type

# body 需要 配置margin 0

# <ul></ul> <p> 有默认格式 要处理

# chrome sticky top -1px 才行

# margin 不计算高度？
```ts
.zxx-scroll-ad {
  position: sticky;
  top: 60px;
  bottom: 100px;
  display: block;
  width: 250px;
  height: 200px;
  /* padding: 0.5em 1em; */
  /* margin: 5em auto; */
  border: solid deepskyblue;
  overflow: auto;
  overscroll-behavior: contain;
  -ms-scroll-chaining: contain;
  background-color: #ebff9c;
}
```
# 子项目t2 下的 App.vue laytest1.html 参考！

```ts
// type Position = 'relative' | 'static' | 'fixed' | 'absolute' | 'sticky';
// const position = ref<Position>('absolute');

// type Auto = number | 'auto';
// const auto = ref<Auto>('auto');
```
      @mouseenter="mouseover"
      @mouseout="mouseout"

# 用hover控制子组件显示
```ts

<div class="asideL"> </div>
<div class="hello1"> </div>

/* ---------------------相邻选择器 实现 hover 控制兄弟 DIV 显示隐藏 --------------  */
.asideL:hover + .hello1 {
  display: block;
  background-color: #ff0505;
}

.hello1 {
  background-color: #2bff83;
  transition: all 0.5s;
  /* display: none; */
}

.hello1:hover {
  background-color: #0054c9;
  transition: all 0.5s;
}

<div class="asideL">
  <div class="hello"> </div>
</div>

/* ---------------------选择器 实现 hover 控制 子DIV 显示隐藏 --------------  */
.asideL:hover .hello {
  display: block;
}

.hello {
  background-color: #ddeeaa;
  display: none;
}

.hello:hover {
  background-color: #0054c9;
  transition: all 0.5s;
}
/* ---------------------选择器 实现 hover 控制 子DIV 显示隐藏 --------------  */
```

# 在父组件里不换行，放入子组件的插槽里
  white-space: nowrap;


# padding 对div高度计算有影响！

```ts
zxx-scroll {
  position: sticky;
  top: 160px;
  bottom: 100px;
  display: block;
  width: 250px;
  height: 200px;
  /* padding: 0.5em 1em;
  margin: 5em auto; */
  border: solid deepskyblue;
  overflow: auto;
  overscroll-behavior: contain;
  -ms-scroll-chaining: contain;
}
```
#  计算属性写法
```ts
interface myTF {
  isA: boolean;
  isB: boolean;
}

const myTFx = computed<myTF>(() => {
  const { hasCover, hasHidden, hasHeader, hasTab } = props;
  return { isA: hasCover, isB: hasHidden || hasHeader || hasTab };
});
```
