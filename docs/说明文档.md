# packages/test01子项目引用 @asialine/xia-ui/XIcon组件
在root下，执行了 pnpm up
```ts
import type { ExtractPropTypes } from "vue";
```
以上必须是 import type

# body 需要 配置margin 0

# <ul></ul> <p> 有默认格式 要处理

# chrome sticky top -1px 才行

# margin 不计算高度？
```ts
.zxx-scroll-ad {
  position: sticky;
  top: 60px;
  bottom: 100px;
  display: block;
  width: 250px;
  height: 200px;
  /* padding: 0.5em 1em; */
  /* margin: 5em auto; */
  border: solid deepskyblue;
  overflow: auto;
  overscroll-behavior: contain;
  -ms-scroll-chaining: contain;
  background-color: #ebff9c;
}
```
# 子项目t2 下的 App.vue laytest1.html 参考！

```ts
// type Position = 'relative' | 'static' | 'fixed' | 'absolute' | 'sticky';
// const position = ref<Position>('absolute');

// type Auto = number | 'auto';
// const auto = ref<Auto>('auto');
```
      @mouseenter="mouseover"
      @mouseout="mouseout"

# 用hover控制子组件显示
```ts

<div class="asideL"> </div>
<div class="hello1"> </div>

/* ---------------------相邻选择器 实现 hover 控制兄弟 DIV 显示隐藏 --------------  */
.asideL:hover + .hello1 {
  display: block;
  background-color: #ff0505;
}

.hello1 {
  background-color: #2bff83;
  transition: all 0.5s;
  /* display: none; */
}

.hello1:hover {
  background-color: #0054c9;
  transition: all 0.5s;
}

<div class="asideL">
  <div class="hello"> </div>
</div>

/* ---------------------选择器 实现 hover 控制 子DIV 显示隐藏 --------------  */
.asideL:hover .hello {
  display: block;
}

.hello {
  background-color: #ddeeaa;
  display: none;
}

.hello:hover {
  background-color: #0054c9;
  transition: all 0.5s;
}
/* ---------------------选择器 实现 hover 控制 子DIV 显示隐藏 --------------  */
```

# 在父组件里不换行，放入子组件的插槽里
  white-space: nowrap;


# padding 对div高度计算有影响！

```ts
zxx-scroll {
  position: sticky;
  top: 160px;
  bottom: 100px;
  display: block;
  width: 250px;
  height: 200px;
  /* padding: 0.5em 1em;
  margin: 5em auto; */
  border: solid deepskyblue;
  overflow: auto;
  overscroll-behavior: contain;
  -ms-scroll-chaining: contain;
}
```
#  计算属性写法
```ts
interface myTF {
  isA: boolean;
  isB: boolean;
}

const myTFx = computed<myTF>(() => {
  const { hasCover, hasHidden, hasHeader, hasTab } = props;
  return { isA: hasCover, isB: hasHidden || hasHeader || hasTab };
});
```

# javascript 观察 DIV的高度变化
```ts
onMounted(() => {
  // 只有 entries[0]有内容，虽然是观察多个，但是一个一个返回的。
  const resizeObserver = new ResizeObserver(entries => {
    entries.forEach(entry => {
      console.log('11111obobobobobobobobobobob', entry);
      eleOb.value = entry;
      if (entry.target.id === 'xia-layout-header') {
        headerHH.value = entry.contentRect.height;
      } else if (entry.target.id === 'xia-layout-tab') {
        tabHH.value = entry.contentRect.height;
      } else if (entry.target.id === 'xia-layout-cover') {
        coverHH.value = entry.contentRect.height;
      } else if (entry.target.id === 'xia-layout-footer') {
        footerHH.value = entry.contentRect.height;
      } else if (entry.target.classList.contains('xia-layout-main')) {
        mainh.value = entry.contentRect.height;
      }
    });
    footerHH.value = headerHH.value + tabHH.value;
  });
  const boxes = document.querySelectorAll('.info') as NodeListOf<Element>;
  boxes.forEach(box => {
    console.log('======obobobobobobobobobobob', box);
    resizeObserver.observe(box);
  });
});
```

```ts
  // const element = document.querySelector('.header') as HTMLElement;
  // headerHeight.value = element === null ? props.hMinHeight : element.offsetHeight;
  // console.log('onMounted headerHeight', element.offsetHeight);
```
